import random
import img_to_planar as img_to_planar
#Used chatgpt to create the sample graphs to test the algorithms efficacy - https://chatgpt.com/share/698bc9df-1180-8004-a495-fbc1b0f8ccdc
class State:
    cycle = 0
    def __init__(self, nodes, arcs):
        self.nodes = nodes #list of node colours
        self.arcs = arcs #list of tuples representing arcs between nodes

    def step(self, colours):
        try: #see if there is an un-coloured node in the graph
            node = self.nodes.index(0)
        except ValueError: #all graphs coloured means we have a solution
            print("All nodes are coloured. Solution found!") 
            self.print_state()
            return True
        
        for colour in range(1, colours+1): #try each of the four colours - should switch this to test different numbers of colours
            if self.is_valid_colour(node, colour):
                self.nodes[node] = colour
                State.cycle += 1 #keep  track of how many iterations / checks we have done
                print("Cycle", State.cycle, ": Assigned colour", colour, "to node", node)

                if self.step(colours): #recursion - will step down until a True (sol is found), or false (no sol) then we backtrack to the last not guaranteed false node
                    return True
                self.nodes[node] = 0 #if first colour failed downwind, reset node uncoloured
        return False
          
    def is_valid_colour(self, node_index, colour): #checks if any arc including node_index has the same colour at the other end
        for a,b in self.arcs:
            if node_index == a and self.nodes[b] == colour: 
                return False
            if node_index == b and self.nodes[a] == colour:
                return False
        return True

    def print_state(self): #print current state of the graph
        print("Nodes and their colours:")
        for i, c in enumerate(self.nodes):
            print(f"Node {i}: Colour {c}")

def min_colour(state):
    colours = 1
    while True:
        print(f"Trying {colours} colours")
        if state.step(colours):
            print(f"Solution found with {colours} colours!")
            break
        print("\n" + "-"*20, f"No solution found with {colours} colours" + "-"*20 + "\n")
        colours += 1


def connector(graph_list, graph_name): #This function takes the graphs with adjacency lists and reformats them to a array of arc tuples
    x = graph_list.get(graph_name)
    arcs = []
    for node, neighbours in x.items():
        for neighbour in neighbours:
            if (neighbour, node) not in arcs: #to avoid duplicates
                arcs.append((node, neighbour))
    return arcs


def canada(): #a graph canada's provinces and territories with arcs representing shared borders
    #These are the basic command to create a graph and run the search:
    arcs = [(0,1),(0,2),(0,3),(1,2),(2,3),(2,4),(2,5),(3,4),(4,6),(5,6),(6,7),(7,8),(8,9),(8,10),(9,12),(12,11),(11,10)] #pairs of nodes represent arcs
    nodes = [0] * 13 #initialize nodes uncoloured
    state = State(nodes, arcs) #instantiate state object
    min_colour(state)

def decrement(arcs):
    for x in range(len(arcs)):
        a, b = arcs[x]
        arcs[x] = (a-1, b-1)
    return arcs

def tough1(): #hand drawn graph - sample images included in repo
    arcs = [(0,1),(0,2),(0,3),(0,5),(1,5),(2,3),(2,5),(3,5),(3,4),(3,6),(3,7),(3,8),(4, 6),(5,6),(5,7),(5,8), (6,8), (7,8),(4,9),(6,9),(8,9)]
    nodes = [0] * 10
    state = State(nodes, arcs)
    min_colour(state)


def medium():   #this is a graph of 30 nodes generated by chatgpt. When using 4 colours it instantly find a solution. Using 3 it checks 72 nodes rather than minimal 29
    arcs = [
        (0,1),(0,2),(0,3),(0,4),
        (1,2),(1,5),(1,6),
        (2,6),(2,7),
        (3,7),(3,8),
        (4,8),(4,9),

        (5,6),(5,10),
        (6,10),(6,11),
        (7,11),(7,12),
        (8,12),(8,13),
        (9,13),(9,14),

        (10,11),(10,15),
        (11,15),(11,16),
        (12,16),(12,17),
        (13,17),(13,18),
        (14,18),(14,19),

        (15,16),(15,20),
        (16,20),(16,21),
        (17,21),(17,22),
        (18,22),(18,23),
        (19,23),(19,24),

        (20,21),(21,22),
        (22,23),(23,24),
        (24,25),(25,26),
        (26,27),(27,28),
        (28,29),(25,29)
    ]
    nodes = [0] * 30
    state = State(nodes, arcs)
    min_colour(state)


def big(): #Even bigger graph of 50 nodes by chatgpt. Amazingly it still finds instant sol with 4 colours, but with three it checks 105 then decides there is no sol
    num_nodes = 50

    arcs = [
        # Core spine
        *[(i, i+1) for i in range(49)],

        # Cross connections
        (0,2),(1,3),(2,4),(3,5),(4,6),(5,7),
        (6,8),(7,9),(8,10),(9,11),(10,12),
        (11,13),(12,14),(13,15),(14,16),

        # Dense mid section
        (15,17),(15,18),(16,18),(16,19),
        (17,18),(17,20),(18,20),(18,21),
        (19,21),(19,22),(20,21),(20,23),
        (21,23),(21,24),(22,24),(22,25),

        # Upper lattice
        (23,24),(23,26),(24,26),(24,27),
        (25,27),(25,28),(26,27),(26,29),
        (27,29),(27,30),(28,30),(28,31),

        # Tail complexity
        (30,31),(30,32),(31,33),
        (32,33),(32,34),(33,35),
        (34,35),(34,36),(35,37),
        (36,37),(36,38),(37,39),
        (38,39),(38,40),(39,41),
        (40,41),(40,42),(41,43),
        (42,43),(42,44),(43,45),
        (44,45),(44,46),(45,47),
        (46,47),(46,48),(47,49)
    ]
    nodes = [0] * 50
    state = State(nodes, arcs)
    min_colour(state)


def cluster(start): #chatpgt function to aid in  non-planar graph creation
    edges = []
    nodes = list(range(start, start+10))
    for i in range(len(nodes)):
        for j in range(i+1, len(nodes)):
            # remove a few edges to avoid a full clique
            if (i + j) % 4 != 0:
                edges.append((nodes[i], nodes[j]))
    return edges

def biggest(): #this is another chatgpt graph WHICH IS NON-PLANAR! This means the 4 colour theorem does not apply. We can see that it does not find a sol with 4 colours and needs 5.
    arcs = []
    for c in range(5):
        arcs += cluster(c * 10)
    
    links = [
    (0,10),(1,11),(2,12),(3,13),(4,14),
    (5,20),(6,21),(7,22),(8,23),(9,24),

    (10,20),(11,21),(12,22),(13,23),(14,24),

    (15,25),(16,26),(17,27),(18,28),(19,29),

    (20,30),(21,31),(22,32),(23,33),(24,34),

    (30,40),(31,41),(32,42),(33,43),(34,44),

    # Cross-links that destroy locality
    (0,21),(1,22),(2,23),(3,24),
    (10,31),(11,32),(12,33),(13,34),
    (20,41),(21,42),(22,43),(23,44),

    # Late-stage conflicts
    (35,45),(36,46),(37,47),(38,48),(39,49),
    (25,35),(26,36),(27,37),(28,38),(29,39)
    ]
    arcs += links

    nodes = [0] * 50
    state = State(nodes, arcs)
    min_colour(state)


#copied driver function from img_to_planar to run the graph colouring on the graph generated from the image
labels, border = img_to_planar.img_planar.img_load()
adjacency = img_to_planar.img_planar.adjacency_list(labels, border)

#ran into problems indexing from node 1, so i just added node 0 as a dummy node to make the indexing work out
buffer = [-1] + [0]*labels.max()
state = State(buffer, adjacency)
min_colour(state)
img_to_planar.img_planar.graph_result(adjacency) #print the graph just to check it is correct.. seems to be





#Run Whichever Graph search you want
#canada()
#tough1()
#medium()
#big()
#biggest()
